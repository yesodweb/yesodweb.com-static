<!doctype html><!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]--><!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]--><!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en"> <!--<![endif]--><head><meta charset="UTF-8"><title>Forms :: Yesod Web Framework Book- Version 1.4</title><meta name="description" content="Yesod is a Haskell web framework for productive development of type-safe, RESTful, high performance web applications."><meta name="viewport" content="width=device-width,initial-scale=1"><link href="/feed" type="application/atom+xml" rel="alternate" title="Yesod Web Framework Blog">
<style>article,aside,details,figcaption,figure,footer,header,hgroup,nav,section{display:block}audio,canvas,video{display:inline-block;*display:inline;*zoom:1}audio:not([controls]){display:none}[hidden]{display:none}html{font-size:100%;overflow-y:scroll;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}body,button,input,select,textarea{font-family:sans-serif}a{color:#00e}a:visited{color:#551a8b}a:focus{outline:thin dotted}a:hover,a:active{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}blockquote{margin:1em 40px}dfn{font-style:italic}mark{background:#ff0;color:#000}pre,code,kbd,samp{font-family:"DejaVu Sans Mono", "Droid Sans Mono", consolas, "courier new", monospace;_font-family:'courier new', monospace;font-size:.85em}pre{white-space:pre;white-space:pre-wrap;word-wrap:break-word}q{quotes:none}q:before,q:after{content:'';content:none}small{font-size:75%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}ul,ol{margin:1em 0;padding:0 0 0 40px}dd{margin:0 0 0 40px}nav ul,nav ol{list-style:none;list-style-image:none}img{border:0;-ms-interpolation-mode:bicubic}svg:not(:root){overflow:hidden}figure{margin:0}form{margin:0}fieldset{margin:0 2px;padding:0.35em 0.625em 0.75em}legend{border:0;*margin-left:-7px}button,input,select,textarea{font-size:100%;margin:0;vertical-align:baseline;*vertical-align:middle}button,input{line-height:normal;*overflow:visible}table button,table input{*overflow:auto}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}pre code{display:block;padding:0.5em;background:#F4F4F4}pre code,pre .ruby .subst,pre .tag .title,pre .lisp .title{color:black}pre .string,pre .title,pre .constant,pre .parent,pre .tag .value,pre .rules .value,pre .rules .value .number,pre .preprocessor,pre .ruby .symbol,pre .ruby .symbol .string,pre .ruby .symbol .keyword,pre .ruby .symbol .keymethods,pre .instancevar,pre .aggregate,pre .template_tag,pre .django .variable,pre .smalltalk .class,pre .addition,pre .flow,pre .stream,pre .bash .variable,pre .apache .tag,pre .apache .cbracket,pre .tex .command,pre .tex .special,pre .erlang_repl .function_or_atom{color:#800}pre .comment,pre .annotation,pre .template_comment,pre .diff .header,pre .chunk{color:#888}pre .number,pre .date,pre .regexp,pre .literal,pre .smalltalk .symbol,pre .smalltalk .char,pre .go .constant,pre .change{color:#080}pre .label,pre .javadoc,pre .ruby .string,pre .decorator,pre .filter .argument,pre .localvars,pre .array,pre .attr_selector,pre .important,pre .pseudo,pre .pi,pre .doctype,pre .deletion,pre .envvar,pre .shebang,pre .apache .sqbracket,pre .nginx .built_in,pre .tex .formula,pre .erlang_repl .reserved,pre .input_number{color:#88F
}pre .css .tag,pre .javadoctag,pre .phpdoc,pre .yardoctag{font-weight:bold}pre .keyword,pre .id,pre .phpdoc,pre .title,pre .built_in,pre .aggregate,pre .smalltalk .class,pre .winutils,pre .bash .variable,pre .apache .tag,pre .go .typename,pre .tex .command{font-weight:bold}pre .nginx .built_in{font-weight:normal}pre .xml .css,pre .xml .javascript,pre .xml .vbscript,pre .tex .formula{opacity:0.5}aside.note{padding:0.5em;border:1px dotted #000}.github-link{font-size:0.6em}.github-link a,.github-link a:visited{text-decoration:none}article > h1:first-child{margin-top:0}figure > h1{margin:0}p code{background-color:#f0f0f0}a.permalink{font-size:50%;text-decoration:none;position:absolute;left:-25px;top:10px}section > h1{position:relative}pre > code{white-space:pre;overflow-x:auto}@media print, (max-width: 700px) {article > h1:first-child{margin-top:25px}section > h1{margin-bottom:0.5em}}.warning{color:red;font-weight:bold}#main figure{border:1px solid #CCC;box-shadow:0 0 3px #CCC inset;padding:1em;margin:2ex 0}#main figure figcaption{text-size:.9em;text-align:center;color:#555}#main figure img{border:solid 1px #CCC}#container{min-width:1094px}dd,p{text-align:justify}body{font-family:'Crimson Text', serif;font-size:1.2em;background-color:#e5eef9}a,a:visited{color:#000}a:hover,a:active{color:#823}nav{box-shadow:0 -5px 20px 20px rgba(41,55,78,0.12);z-index:100;background-color:#29374e;padding:5px;font-family:'Lato';font-size:0.80em;font-weight:400;position:fixed;width:100%;top:0}nav ul{margin:0;padding:0;text-align:right}nav ul li{display:inline;margin-right:3em}nav ul li.googleplus{position:relative;top:2px;margin-right:3em}nav ul li.feedlink{position:relative;top:3px}nav a,nav a:visited{color:#eee;text-decoration:none}#spotlight{background-image:-webkit-radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);background-image:-moz-radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);background-image:-o-radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);background-image:-ms-radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);background-image:radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);position:absolute;width:1050px;height:300px;top:0;left:50%;margin-left:-475px;z-index:-1}div.headergroup{width:1050px;margin:0 auto;padding-top:2.6em;padding-bottom:1.3em}div.headergroup a{text-decoration:none;display:flex}div.headergroup div.homepage-logo{text-align:center;width:550px;height:105px;margin-left:75px}div.headergroup div.homepage-logo div.logo-image{background:url(/static/logo-home2-no-esod-smaller2.png?etag=uBLSXtRu) no-repeat center center;width:100%;height:75px}div.headergroup div.homepage-logo div.logo-text{color:#29374e;padding-top:0.2em;font-family:'Lato';font-weight:300;font-size:1.2em;padding-bottom:0.3em}div.headergroup div.homepage-info{text-align:left;font-family:'Lato';font-weight:300;font-size:0.8em;line-height:1.6em;width:220px}div.headergroup h2{margin-bottom:0;font-size:1.4em;margin-top:0;padding-top:0.4em;padding-bottom:1em}h1,h2,h3,h4,h5,h6,dt{color:#474f6b;font-family:'Lato';font-weight:400}h1{font-weight:300;font-size:1.8em}h2,section > section > h1{font-weight:400;font-size:1.5em;margin-bottom:0.5em}h3,section > section > section > h1{font-weight:400;font-size:1.2em;margin-bottom:0.5em}h1 span{display:none}section{display:table-cell}section h2{margin-top:2.2em;margin-bottom:0}section img{max-width:100%}section section{display:block;width:auto;padding:0;margin:0}section.why{width:600px;padding-left:90px;padding-right:90px}section.why article{width:600px}section.getting-started{background-color:#f4f4f4;width:300px;padding-left:50px;padding-right:50px}section.getting-started h2{font-size:1.2em;margin-bottom:0.7em;margin-top:1.8em}section.getting-started ul{font-family:'Lato';font-size:0.75em;font-weight:500;margin-bottom:20px;line-height:2em;list-style-type:none;margin-bottom:50px;padding-left:0}section.getting-started ul ul{font-size:.9em }section.getting-started div{font-family:'Lato';padding-left:20px}#main{box-shadow:0 10px 25px 25px rgba(41,55,78,0.05);background-color:#fff;position:relative;width:1050px;margin:0 auto}aside#announcement{box-shadow:0 0 20px 10px rgba(41,55,78,0.12);height:20px;margin:0 auto;position:relative;width:1080px;background-color:#29374e;color:#eee;padding:0.5em;font-family:'Lato';font-weight:400;font-size:0.8em;z-index:50}aside#announcement div.msg{margin-left:105px}aside#announcement div.tri-left,aside#announcement div.tri-right{width:0;height:0;position:absolute;bottom:-21px;border-style:solid}aside#announcement div.tri-left{left:0;border-width:11px 11px 10px 11px;border-color:#0b1b30 #0b1b30 transparent transparent}aside#announcement div.tri-right{right:0;border-width:11px 11px 11px 10px;border-color:#0b1b30 transparent transparent #0b1b30}aside#announcement a,aside#announcement a:visited{color:#eee;text-decoration:underline}aside#announcement span.date{font-style:italic;font-size:0.8em}#feedlink{display:inline-block;height:16px;width:16px;background:url(/static/blog.png?etag=oPHrQ5qo)}#feedlink span{display:none}dt{font-weight:400;font-size:1.05em;margin-bottom:0.7em;margin-top:2.3em}dd,p{margin:0;font-size:1em;line-height:155%;margin-bottom:0.5em}p.what{display:none;font-size:1.4em;padding:0 200px}#instantclick{display:none}@media print, (max-width: 700px) {body{background-color:#fff;padding:3px}.googleplus,.feedlink,.headergroup,#announcement,#comments,#disqus_thread,#spotlight,#license,.github-link,.oreilly,.main-listing{display:none}div .headergroup{display:none}#container > nav{background-color:#fff;box-shadow:none}#container > nav > ul{text-align:left}#container > nav > ul a,#container > nav > ul a:visited{color:#00f}#main,div#container,section.why > article{width:auto;min-width:0}#main{box-shadow:none;position:static;margin:0}section.why,section.getting-started{display:block;width:auto;padding:0;background-color:#fff}hgroup h1[itemprop=name],hgroup h2,hgroup h3{margin:0}hgroup h1[itemprop=name] img,hgroup h2 img,hgroup h3 img{display:none}dd,p,dt{margin:12px}}@media print {nav{display:none}section.getting-started{display:none}}</style><!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><link href="//fonts.googleapis.com/css?family=Crimson+Text:400,400italic,600,600italic,700,700italic" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic" rel="stylesheet" type="text/css"><script>document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/,'js');</script></head><body itemscope itemtype="http://schema.org/Product"><div id="spotlight"></div><div id="container"><nav><ul><li><a href="/book">book</a></li><li><a href="/wiki">cookbook</a></li><li><a href="/blog">blog</a></li><li><a href="/wiki/Home">wiki</a></li><li class="feedlink"><a href="/feed" id="feedlink"><span>newsfeed</span></a></li></ul></nav><div class="headergroup"><a href="/"><div class="homepage-logo"><div class="logo-image"></div><div class="logo-text">Yesod Web Framework</div></div><div class="homepage-info">Yesod is a Haskell web framework for productive development of type-safe, RESTful, high performance web applications.</div></a></div><aside id="announcement"><div class="tri-left"></div><div class="tri-right"></div><div class="msg"><span class="subject">Forms :: Yesod Web Framework Book- Version 1.4</span></div></aside><div id="main" role="main"><section class="why"><p class="github-link"><a href="https://github.com/yesodweb/yesodweb.com-content/tree/version1.4/book/asciidoc/forms.asciidoc">View source on Github</a>
</p>
<article><h1>Forms</h1>


<p>I’ve mentioned the boundary issue already: whenever data enters or leaves an
application, we need to validate it. Probably the most difficult place this
occurs is forms. Coding forms is complex; in an ideal world, we’d like a
solution that addresses the following problems:</p>
<ul>
<li>
<p>
Ensure data is valid.
</p>
</li>
<li>
<p>
Marshal string data in the form submission to Haskell datatypes.
</p>
</li>
<li>
<p>
Generate HTML code for displaying the form.
</p>
</li>
<li>
<p>
Generate Javascript to do clientside validation and provide more
  user-friendly widgets, such as date pickers.
</p>
</li>
<li>
<p>
Build up more complex forms by combining together simpler forms.
</p>
</li>
<li>
<p>
Automatically assign names to our fields that are guaranteed to be unique.
</p>
</li>
</ul>
<p>The yesod-form package provides all these features in a simple, declarative
API. It builds on top of Yesod’s widgets to simplify styling of forms and
applying Javascript appropriately. And like the rest of Yesod, it uses
Haskell’s type system to make sure everything is working correctly.</p>
<section id="forms_synopsis">
<h1>Synopsis</h1>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell active web">{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}
import           Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import           Data.Text           (Text)
import           Data.Time           (Day)
import           Yesod
import           Yesod.Form.Jquery

data App = App

mkYesod &quot;App&quot; [parseRoutes|
/ HomeR GET
/person PersonR POST
|]

instance Yesod App

-- Tells our application to use the standard English messages.
-- If you want i18n, then you can supply a translating function instead.
instance RenderMessage App FormMessage where
    renderMessage _ _ = defaultFormMessage

-- And tell us where to find the jQuery libraries. We&#39;ll just use the defaults,
-- which point to the Google CDN.
instance YesodJquery App

-- The datatype we wish to receive from the form
data Person = Person
    { personName          :: Text
    , personBirthday      :: Day
    , personFavoriteColor :: Maybe Text
    , personEmail         :: Text
    , personWebsite       :: Maybe Text
    }
  deriving Show

-- Declare the form. The type signature is a bit intimidating, but here&#39;s the
-- overview:
--
-- * The Html parameter is used for encoding some extra information. See the
-- discussion regarding runFormGet and runFormPost below for further
-- explanation.
--
-- * We have our Handler as the inner monad, which indicates which site this is
-- running in.
--
-- * FormResult can be in three states: FormMissing (no data available),
-- FormFailure (invalid data) and FormSuccess
--
-- * The Widget is the viewable form to place into the web page.
--
-- Note that the scaffolded site provides a convenient Form type synonym,
-- so that our signature could be written as:
--
-- &gt; personForm :: Form Person
--
-- For our purposes, it&#39;s good to see the long version.
personForm :: Html -&gt; MForm Handler (FormResult Person, Widget)
personForm = renderDivs $ Person
    &lt;$&gt; areq textField &quot;Name&quot; Nothing
    &lt;*&gt; areq (jqueryDayField def
        { jdsChangeYear = True -- give a year dropdown
        , jdsYearRange = &quot;1900:-5&quot; -- 1900 till five years ago
        }) &quot;Birthday&quot; Nothing
    &lt;*&gt; aopt textField &quot;Favorite color&quot; Nothing
    &lt;*&gt; areq emailField &quot;Email address&quot; Nothing
    &lt;*&gt; aopt urlField &quot;Website&quot; Nothing

-- The GET handler displays the form
getHomeR :: Handler Html
getHomeR = do
    -- Generate the form to be displayed
    (widget, enctype) &lt;- generateFormPost personForm
    defaultLayout
        [whamlet|
            &lt;p&gt;
                The widget generated contains only the contents
                of the form, not the form tag itself. So...
            &lt;form method=post action=@{PersonR} enctype=#{enctype}&gt;
                ^{widget}
                &lt;p&gt;It also doesn&#39;t include the submit button.
                &lt;button&gt;Submit
        |]

-- The POST handler processes the form. If it is successful, it displays the
-- parsed person. Otherwise, it displays the form again with error messages.
postPersonR :: Handler Html
postPersonR = do
    ((result, widget), enctype) &lt;- runFormPost personForm
    case result of
        FormSuccess person -&gt; defaultLayout [whamlet|&lt;p&gt;#{show person}|]
        _ -&gt; defaultLayout
            [whamlet|
                &lt;p&gt;Invalid input, let&#39;s try again.
                &lt;form method=post action=@{PersonR} enctype=#{enctype}&gt;
                    ^{widget}
                    &lt;button&gt;Submit
            |]

main :: IO ()
main = warp 3000 App</code></pre>
</section>
<section id="forms_kinds_of_forms">
<h1>Kinds of Forms</h1>
<p>Before jumping into the types themselves, we should begin with an overview of
the different kinds of forms. There are three categories:</p>
<dl>
<dt>
Applicative
</dt><dd>
<p>
These are the most commonly used (it’s what appeared in the
synopsis). Applicative gives us some nice properties of letting error messages
coalesce together and keep a very high-level, declarative approach. (For more
information on applicative code, see
<a href="http://www.haskell.org/haskellwiki/Applicative_functor">the Haskell
wiki</a>.)
</p>
</dd>
<dt>
Monadic
</dt><dd>
<p>
A more powerful alternative to applicative. While this allows you
more flexibility, it does so at the cost of being more verbose. Useful if you
want to create forms that don’t fit into the standard two-column look.
</p>
</dd>
<dt>
Input
</dt><dd>
<p>
Used only for receiving input. Does not generate any HTML for receiving
the user input. Useful for interacting with existing forms.
</p>
</dd>
</dl>
<p>In addition, there are a number of different variables that come into play for
each form and field you will want to set up:</p>
<ul>
<li>
<p>
Is the field required or optional?
</p>
</li>
<li>
<p>
Should it be submitted with GET or POST?
</p>
</li>
<li>
<p>
Does it have a default value, or not?
</p>
</li>
</ul>
<p>An overriding goal is to minimize the number of field definitions and let them
work in as many contexts as possible. One result of this is that we end up with
a few extra words for each field. In the synopsis, you may have noticed things
like <code>areq</code> and that extra <code>Nothing</code> parameter. We’ll cover why all of those
exist in the course of this chapter, but for now realize that by making these
parameters explicit, we are able to reuse the individuals fields (like
<code>intField</code>) in many different ways.</p>
<p>A quick note on naming conventions. Each form type has a one-letter prefix (A,
M and I) which is used in a few places, such as saying <code>MForm</code>. We also use req
and opt to mean required and optional. Combining these, we create a required
applicative field with <code>areq</code>, or an optional input field with <code>iopt</code>.</p>
</section>
<section id="forms_types">
<h1>Types</h1>
<p>The <code>Yesod.Form.Types</code> module declares a few types. We won’t cover all the types
available, but will instead focus on the most crucial. Let’s start with some of
the simple ones:</p>
<dl>
<dt>
Enctype
</dt><dd>
<p>
The encoding type, either <code>UrlEncoded</code> or <code>Multipart</code>. This datatype
declares an instance of <code>ToHtml</code>, so you can use the enctype directly in
Hamlet.
</p>
</dd>
<dt>
FormResult
</dt><dd>
<p>
Has one of three possible states: <code>FormMissing</code> if no data was
submitted, <code>FormFailure</code> if there was an error parsing the form (e.g., missing
a required field, invalid content), or <code>FormSuccess</code> if everything went
smoothly.
</p>
</dd>
<dt>
FormMessage
</dt><dd>
<p>
Represents all of the different messages that can be generated as
a data type. For example, <code>MsgInvalidInteger</code> is used by the library to
indicate that the textual value provided is not an integer. By keeping this
data highly structured, you are able to provide any kind of rendering function
you want, which allows for internationalization (i18n) of your application.
</p>
</dd>
</dl>
<p>Next we have some datatypes used for defining individual fields. We define a
field as a single piece of information, such as a number, a string, or an email
address. Fields are combined together to build forms.</p>
<dl>
<dt>
Field
</dt><dd>
<p>
Defines two pieces of functionality: how to parse the text input from a
user into a Haskell value, and how to create the widget to be displayed to the
user. <code>yesod-form</code> defines a number of individual Fields in <code>Yesod.Form.Fields</code>.
</p>
</dd>
<dt>
FieldSettings
</dt><dd>
<p>
Basic information on how a field should be displayed, such as
the display name, an optional tooltip, and possibly hardcoded <code>id</code> and <code>name</code>
attributes. (If none are provided, they are automatically generated.) Note that
<code>FieldSettings</code> provides an <code>IsString</code> instance, so when you need to provide a
<code>FieldSettings</code> value, you can actually type in a literal string. That’s how we
interacted with it in the synopsis.
</p>
</dd>
</dl>
<p>And finally, we get to the important stuff: the forms themselves. There are
three types for this: <code>MForm</code> is for monadic forms, <code>AForm</code> for applicative and
<code>FormInput</code> for input. <code>MForm</code> is actually a type synonym for a
monad stack that provides the following features:</p>
<ul>
<li>
<p>
A <code>Reader</code> monad giving us the parameters submitted by the user, the
  foundation datatype and the list of languages the user supports. The last two
  are used for rendering of the <code>FormMessage</code>s to support i18n (more on this
  later).
</p>
</li>
<li>
<p>
A <code>Writer</code> monad keeping track of the <code>Enctype</code>. A form will always be
  <code>UrlEncoded</code>, unless there is a file input field, which will force us to use
  multipart instead.
</p>
</li>
<li>
<p>
A <code>State</code> monad keeping track of generated names and identifiers for fields.
</p>
</li>
</ul>
<p>An <code>AForm</code> is pretty similar. However, there are a few major differences:</p>
<ul>
<li>
<p>
It produces a list of <code>FieldView</code>s, which are used for tracking what we
  will display to the user. This allows us to keep an abstract idea of the form
  display, and then at the end of the day choose an appropriate function for
  laying it out on the page. In the synopsis, we used <code>renderDivs</code>, which
  creates a bunch of div tags. Two other options are <code>renderBootstrap</code> and
  <code>renderTable</code>.
</p>
</li>
<li>
<p>
It does not provide a <code>Monad</code> instance. The goal of <code>Applicative</code> is to allow
  the entire form to run, grab as much information on each field as possible,
  and then create the final result. This cannot work in the context of <code>Monad</code>.
</p>
</li>
</ul>
<p>A <code>FormInput</code> is even simpler: it returns either a list of error messages or a
result.</p>
</section>
<section id="forms_converting">
<h1>Converting</h1>
<p>“But wait a minute,” you say. “You said the synopsis uses applicative forms,
but I’m sure the type signature said <code>MForm</code>. Shouldn’t it be Monadic?” That’s
true, the final form we produced was monadic. But what really happened is that
we converted an applicative form to a monadic one.</p>
<p>Again, our goal is to reuse code as much as possible, and minimize the number
of functions in the API. And Monadic forms are more powerful than Applicative,
if a bit clumsy, so anything that can be expressed in an Applicative form could
also be expressed in a Monadic form. There are two core functions that help out
with this: <code>aformToForm</code> converts any applicative form to a monadic one, and
<code>formToAForm</code> converts certain kinds of monadic forms to applicative forms.</p>
<p>“But wait <em role="strong">another</em> minute,” you insist. “I didn’t see any <code>aformToForm</code>!”
Also true. The <code>renderDivs</code> function takes care of that for us.</p>
</section>
<section id="forms_create_literal_aform_literal_s">
<h1>Create <code>AForm</code>s</h1>
<p>Now that I’ve (hopefully) convinced you that in our synopsis we were really
dealing with applicative forms, let’s have a look and try to understand how
these things get created. Let’s take a simple example:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">data Car = Car
    { carModel :: Text
    , carYear  :: Int
    }
  deriving Show

carAForm :: AForm Handler Car
carAForm = Car
    &lt;$&gt; areq textField &quot;Model&quot; Nothing
    &lt;*&gt; areq intField &quot;Year&quot; Nothing

carForm :: Html -&gt; MForm Handler (FormResult Car, Widget)
carForm = renderTable carAForm</code></pre>
<p>Here, we’ve explicitly split up applicative and monadic forms. In <code>carAForm</code>,
we use the <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> operators. This should not be surprising; these are
almost always used in applicative-style code. And we have one line for each
record in our <code>Car</code> datatype. Perhaps also unsurprisingly, we have a
<code>textField</code> for the <code>Text</code> record, and an <code>intField</code> for the <code>Int</code> record.</p>
<p>Let’s look a bit more closely at the <code>areq</code> function. Its (simplified) type
signature is <code>Field a → FieldSettings → Maybe a → AForm a</code>. That
first argument specifies the datatype of this field, how to parse
it, and how to render it. The next argument, <code>FieldSettings</code>, tells us the
label, tooltip, name and ID of the field. In this case, we’re using the
previously-mentioned <code>IsString</code> instance of <code>FieldSettings</code>.</p>
<p>And what’s up with that <code>Maybe a</code>? It provides the optional default value. For
example, if we want our form to fill in &quot;2007&quot; as the default car year, we
would use <code>areq intField &quot;Year&quot; (Just 2007)</code>. We can even take this to the next
level, and have a form that takes an optional parameter giving the default
values.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">carAForm :: Maybe Car -&gt; AForm Handler Car
carAForm mcar = Car
    &lt;$&gt; areq textField &quot;Model&quot; (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq intField  &quot;Year&quot;  (carYear  &lt;$&gt; mcar)</code></pre>
<section id="forms_optional_fields">
<h1>Optional fields</h1>
<p>Suppose we wanted to have an optional field (like the car color). All we do
instead is use the <code>aopt</code> function.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">carAForm :: AForm Handler Car
carAForm = Car
    &lt;$&gt; areq textField &quot;Model&quot; Nothing
    &lt;*&gt; areq intField &quot;Year&quot; Nothing
    &lt;*&gt; aopt textField &quot;Color&quot; Nothing</code></pre>
<p>And like required fields, the last argument is the optional default value.
However, this has two layers of Maybe wrapping. This is actually a bit
redundant, but it makes it much easier to write code that takes an optional
default form parameter, such as in the next example.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">carAForm :: Maybe Car -&gt; AForm Handler Car
carAForm mcar = Car
    &lt;$&gt; areq textField &quot;Model&quot; (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq intField  &quot;Year&quot;  (carYear  &lt;$&gt; mcar)
    &lt;*&gt; aopt textField &quot;Color&quot; (carColor &lt;$&gt; mcar)

carForm :: Html -&gt; MForm Handler (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car &quot;Forte&quot; 2010 $ Just &quot;gray&quot;</code></pre>
</section>
</section>
<section id="forms_validation">
<h1>Validation</h1>
<p>How would we make our form only accept cars created after 1990? If you
remember, we said above that the <code>Field</code> itself contained the information on
what is a valid entry. So all we need to do is write a new <code>Field</code>, right?
Well, that would be a bit tedious. Instead, let’s just modify an existing one:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">carAForm :: Maybe Car -&gt; AForm Handler Car
carAForm mcar = Car
    &lt;$&gt; areq textField    &quot;Model&quot; (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField &quot;Year&quot;  (carYear  &lt;$&gt; mcar)
    &lt;*&gt; aopt textField    &quot;Color&quot; (carColor &lt;$&gt; mcar)
  where
    errorMessage :: Text
    errorMessage = &quot;Your car is too old, get a new one!&quot;

    carYearField = check validateYear intField

    validateYear y
        | y &lt; 1990 = Left errorMessage
        | otherwise = Right y</code></pre>
<p>The trick here is the <code>check</code> function. It takes a function (<code>validateYear</code>)
that returns either an error message or a modified field value. In this
example, we haven’t modified the value at all. That is usually going to be the
case. This kind of checking is very common, so we have a shortcut:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">carYearField = checkBool (&gt;= 1990) errorMessage intField</code></pre>
<p><code>checkBool</code> takes two parameters: a condition that must be fulfilled, and an
error message to be displayed if it was not.</p>
<aside class="note"><p>You may have noticed the explicit <code>Text</code> type signature on
<code>errorMessage</code>. In the presence of <code>OverloadedStrings</code>, this is necessary. In
order to support i18n, messages can have many different datatypes, and GHC has
no way of determining which instance of <code>IsString</code> you intended to use.</p></aside>
<p>It’s great to make sure the car isn’t too old. But what if we want to make sure
that the year specified is not from the future? In order to look up the current
year, we’ll need to run some <code>IO</code>. For such circumstances, we’ll need <code>checkM</code>,
which allows our validation code to perform arbitrary actions:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">    carYearField = checkM inPast $ checkBool (&gt;= 1990) errorMessage intField

    inPast y = do
        thisYear &lt;- liftIO getCurrentYear
        return $ if y &lt;= thisYear
            then Right y
            else Left (&quot;You have a time machine!&quot; :: Text)

getCurrentYear :: IO Int
getCurrentYear = do
    now &lt;- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year</code></pre>
<p><code>inPast</code> is a function that will return an <code>Either</code> result in the <code>Handler</code>
monad. We use <code>liftIO getCurrentYear</code> to get the current year and then compare
it against the user-supplied year. Also, notice how we can chain together
multiple validators.</p>
<aside class="note"><p>Since the <code>checkM</code> validator runs in the <code>Handler</code> monad, it has access
to a lot of the stuff you can normally do in Yesod. This is especially useful
for running database actions, which we’ll cover in the Persistent chapter.</p></aside>
</section>
<section id="forms_more_sophisticated_fields">
<h1>More sophisticated fields</h1>
<p>Our color entry field is nice, but it’s not exactly user-friendly. What we
really want is a drop-down list.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -&gt; AForm Handler Car
carAForm mcar = Car
    &lt;$&gt; areq textField &quot;Model&quot; (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField &quot;Year&quot; (carYear &lt;$&gt; mcar)
    &lt;*&gt; aopt (selectFieldList colors) &quot;Color&quot; (carColor &lt;$&gt; mcar)
  where
    colors :: [(Text, Color)]
    colors = [(&quot;Red&quot;, Red), (&quot;Blue&quot;, Blue), (&quot;Gray&quot;, Gray), (&quot;Black&quot;, Black)]</code></pre>
<p><code>selectFieldList</code> takes a list of pairs. The first item in the pair is the text displayed to the user in the drop-down list, and the second item is the actual Haskell value. Of course, the code above looks really repetitive; we can get the same result using the Enum and Bounded instance GHC automatically derives for us.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">colors = map (pack . show &amp;&amp;&amp; id) [minBound..maxBound]</code></pre>
<p><code>[minBound..maxBound]</code> gives us a list of all the different <code>Color</code> values. We
then apply a <code>map</code> and <code>&amp;&amp;&amp;</code> (a.k.a, the fan-out operator) to turn that into a
list of pairs. And even this can be simplified by using the <code>optionsEnum</code>
function provided by yesod-form, which would turn out original code into:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">carAForm :: Maybe Car -&gt; AForm Handler Car
carAForm mcar = Car
    &lt;$&gt; areq textField &quot;Model&quot; (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField &quot;Year&quot; (carYear &lt;$&gt; mcar)
    &lt;*&gt; aopt (selectField optionsEnum) &quot;Color&quot; (carColor &lt;$&gt; mcar)</code></pre>
<p>Some people prefer radio buttons to drop-down lists. Fortunately, this is just a one-word change.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">carAForm = Car
    &lt;$&gt; areq textField                    &quot;Model&quot; Nothing
    &lt;*&gt; areq intField                     &quot;Year&quot;  Nothing
    &lt;*&gt; aopt (radioField optionsEnum) &quot;Color&quot; Nothing</code></pre>
</section>
<section id="forms_running_forms">
<h1>Running forms</h1>
<p>At some point, we’re going to need to take our beautiful forms and produce some
results. There are a number of different functions available for this, each
with its own purpose. I’ll go through them, starting with the most common.</p>
<dl>
<dt>
runFormPost
</dt><dd>
<p>
This will run your form against any submitted <code>POST</code> parameters.
If this is not a <code>POST</code> submission, it will return a <code>FormMissing</code>. This
automatically inserts a security token as a hidden form field to avoid
<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">cross-site request
forgery</a> (CSRF) attacks.
</p>
</dd>
<dt>
runFormGet
</dt><dd>
<p>
The equivalent of <code>runFormPost</code> for GET parameters. In order to
distinguish a normal <code>GET</code> page load from a <code>GET</code> submission, it includes an
extra <code>_hasdata</code> hidden field in the form. Unlike runFormPost, it does
not include CSRF protection.
</p>
</dd>
<dt>
runFormPostNoToken
</dt><dd>
<p>
Same as <code>runFormPost</code>, but does not include (or require)
the CSRF security token.
</p>
</dd>
<dt>
generateFormPost
</dt><dd>
<p>
Instead of binding to existing <code>POST</code> parameters, acts as if
there are none. This can be useful when you want to generate a new form after a
previous form was submitted, such as in a wizard.
</p>
</dd>
<dt>
generateFormGet
</dt><dd>
<p>
Same as <code>generateFormPost</code>, but for <code>GET</code>.
</p>
</dd>
</dl>
<p>The return type from the first three is <code>((FormResult a, Widget), Enctype)</code>.
The <code>Widget</code> will already have any validation errors and previously submitted
values.</p>
<aside class="note"><p>Why the nested tuple instead of a specialized datatype? It’s because
<code>runFormPostNoToken</code> and <code>runFormGet</code> can both be used with forms that don’t
return a <code>FormResult</code> or <code>Widget</code>, which can be useful when dealing with more
complicated monadic forms (discussed below).</p></aside>
</section>
<section id="forms_i18n">
<h1>i18n</h1>
<p>There have been a few references to i18n in this chapter. The topic will get
more thorough coverage in its own chapter, but since it has such a profound
effect on <code>yesod-form</code>, I wanted to give a brief overview. The idea behind i18n
in Yesod is to have data types represent messages. Each site can have an
instance of <code>RenderMessage</code> for a given datatype which will translate that
message based on a list of languages the user accepts. As a result of all this,
there are a few things you should be aware of:</p>
<ul>
<li>
<p>
There is an automatic instance of <code>RenderMessage</code> for <code>Text</code> in every site,
  so you can just use plain strings if you don’t care about i18n support.
  However, you may need to use explicit type signatures occasionally.
</p>
</li>
<li>
<p>
<code>yesod-form</code> expresses all of its messages in terms of the <code>FormMessage</code> datatype. Therefore, to use <code>yesod-form</code>, you’ll need to have an appropriate <code>RenderMessage</code> instance. A simple one that uses the default English translations would be:
</p>
</li>
</ul>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">instance RenderMessage App FormMessage where
    renderMessage _ _ = defaultFormMessage</code></pre>
<p>This is provided automatically by the scaffolded site.</p>
</section>
<section id="forms_monadic_forms">
<h1>Monadic Forms</h1>
<p>Often times, a simple form layout is adequate, and applicative forms excel at
this approach. Sometimes, however, you’ll want to have a more customized look
to your form.</p>
<figure id="monadic-x-4"><h1>A non-standard form layout</h1>

  
  <img src="image/monadic-form" />
  
  

</figure>
<p>For these use cases, monadic forms fit the bill. They are a bit more verbose
than their applicative cousins, but this verbosity allows you to have complete
control over what the form will look like. In order to generate the form above,
we could code something like this.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell active web">{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}
import           Control.Applicative
import           Data.Text           (Text)
import           Yesod

data App = App

mkYesod &quot;App&quot; [parseRoutes|
/ HomeR GET
|]

instance Yesod App

instance RenderMessage App FormMessage where
    renderMessage _ _ = defaultFormMessage

data Person = Person
    { personName :: Text
    , personAge  :: Int
    }
    deriving Show

personForm :: Html -&gt; MForm Handler (FormResult Person, Widget)
personForm extra = do
    (nameRes, nameView) &lt;- mreq textField &quot;this is not used&quot; Nothing
    (ageRes, ageView) &lt;- mreq intField &quot;neither is this&quot; Nothing
    let personRes = Person &lt;$&gt; nameRes &lt;*&gt; ageRes
    let widget = do
            toWidget
                [lucius|
                    ##{fvId ageView} {
                        width: 3em;
                    }
                |]
            [whamlet|
                #{extra}
                &lt;p&gt;
                    Hello, my name is #
                    ^{fvInput nameView}
                    \ and I am #
                    ^{fvInput ageView}
                    \ years old. #
                    &lt;input type=submit value=&quot;Introduce myself&quot;&gt;
            |]
    return (personRes, widget)

getHomeR :: Handler Html
getHomeR = do
    ((res, widget), enctype) &lt;- runFormGet personForm
    defaultLayout
        [whamlet|
            &lt;p&gt;Result: #{show res}
            &lt;form enctype=#{enctype}&gt;
                ^{widget}
        |]

main :: IO ()
main = warp 3000 App</code></pre>
<p>Similar to the applicative <code>areq</code>, we use <code>mreq</code> for monadic forms. (And yes,
there’s also <code>mopt</code> for optional fields.) But there’s a big difference: <code>mreq</code>
gives us back a pair of values. Instead of hiding away the FieldView value and
automatically inserting it into a widget, we have the ability to insert it as
we see fit.</p>
<p><code>FieldView</code> has a number of pieces of information. The most important is
<code>fvInput</code>, which is the actual form field. In this example, we also use <code>fvId</code>,
which gives us back the HTML <code>id</code> attribute of the input tag. In our example,
we use that to specify the width of the field.</p>
<p>You might be wondering what the story is with the “this is not used” and
“neither is this” values. <code>mreq</code> takes a <code>FieldSettings</code> as its second
argument. Since <code>FieldSettings</code> provides an <code>IsString</code> instance, the strings
are essentially expanded by the compiler to:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">fromString &quot;this is not used&quot; == FieldSettings
    { fsLabel = &quot;this is not used&quot;
    , fsTooltip = Nothing
    , fsId = Nothing
    , fsName = Nothing
    , fsAttrs = []
    }</code></pre>
<p>In the case of applicative forms, the <code>fsLabel</code> and <code>fsTooltip</code> values are used
when constructing your HTML. In the case of monadic forms, Yesod does not
generate any of the “wrapper” HTML for you, and therefore these values are
ignored. However, we still keep the <code>FieldSettings</code> parameter to allow you to
override the <code>id</code> and <code>name</code> attributes of your fields if desired.</p>
<p>The other interesting bit is the <code>extra</code> value. <code>GET</code> forms include an extra
field to indicate that they have been submitted, and <code>POST</code> forms include a
security token to prevent CSRF attacks. If you don’t include this extra hidden
field in your form, the form submission will fail.</p>
<p>Other than that, things are pretty straight-forward. We create our <code>personRes</code>
value by combining together the <code>nameRes</code> and <code>ageRes</code> values, and then return
a tuple of the person and the widget. And in the <code>getHomeR</code> function,
everything looks just like an applicative form. In fact, you could swap out our
monadic form with an applicative one and the code would still work.</p>
</section>
<section id="forms_input_forms">
<h1>Input forms</h1>
<p>Applicative and monadic forms handle both the generation of your HTML code and
the parsing of user input. Sometimes, you only want to do the latter, such as
when there’s an already-existing form in HTML somewhere, or if you want to
generate a form dynamically using Javascript. In such a case, you’ll want input
forms.</p>
<p>These work mostly the same as applicative and monadic forms, with some differences:</p>
<ul>
<li>
<p>
You use <code>runInputPost</code> and <code>runInputGet</code>.
</p>
</li>
<li>
<p>
You use <code>ireq</code> and <code>iopt</code>. These functions now only take two arguments: the
  field type and the name (i.e., HTML <code>name</code> attribute) of the field in
  question.
</p>
</li>
<li>
<p>
After running a form, it returns the value. It doesn’t return a widget or an
  encoding type.
</p>
</li>
<li>
<p>
If there are any validation errors, the page returns an &quot;invalid arguments&quot;
  error page.
</p>
</li>
</ul>
<p>You can use input forms to recreate the previous example. Note, however, that
the input version is less user friendly. If you make a mistake in an
applicative or monadic form, you will be brought back to the same page, with
your previously entered values in the form, and an error message explaining what
you need to correct. With input forms, the user simply gets an error message.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell active web">{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}
import           Control.Applicative
import           Data.Text           (Text)
import           Yesod

data App = App

mkYesod &quot;App&quot; [parseRoutes|
/ HomeR GET
/input InputR GET
|]

instance Yesod App

instance RenderMessage App FormMessage where
    renderMessage _ _ = defaultFormMessage

data Person = Person
    { personName :: Text
    , personAge  :: Int
    }
    deriving Show

getHomeR :: Handler Html
getHomeR = defaultLayout
    [whamlet|
        &lt;form action=@{InputR}&gt;
            &lt;p&gt;
                My name is
                &lt;input type=text name=name&gt;
                and I am
                &lt;input type=text name=age&gt;
                years old.
                &lt;input type=submit value=&quot;Introduce myself&quot;&gt;
    |]

getInputR :: Handler Html
getInputR = do
    person &lt;- runInputGet $ Person
                &lt;$&gt; ireq textField &quot;name&quot;
                &lt;*&gt; ireq intField &quot;age&quot;
    defaultLayout [whamlet|&lt;p&gt;#{show person}|]

main :: IO ()
main = warp 3000 App</code></pre>
</section>
<section id="forms_custom_fields">
<h1>Custom fields</h1>
<p>The fields that come built-in with Yesod will likely cover the vast majority of
your form needs. But occasionally, you’ll need something more specialized.
Fortunately, you can create new fields in Yesod yourself. The <code>Field</code> constructor
has three values: <code>fieldParse</code> takes a list of values submitted by the user and
returns one of three results:</p>
<ul>
<li>
<p>
An error message saying validation failed.
</p>
</li>
<li>
<p>
The parsed value.
</p>
</li>
<li>
<p>
Nothing, indicating that no data was supplied.
</p>
</li>
</ul>
<p>That last case might sound surprising. It would seem that Yesod can
automatically know that no information is supplied when the input list is
empty. But in reality, for some field types, the lack of any input is actually
valid input. Checkboxes, for instance, indicate an unchecked state by sending
in an empty list.</p>
<p>Also, what’s up with the list? Shouldn’t it be a <code>Maybe</code>? That’s also not the
case. With grouped checkboxes and multi-select lists, you’ll have multiple
widgets with the same name. We also use this trick in our example below.</p>
<p>The second value in the constructor is <code>fieldView</code>, and it renders a widget to display to the
user. This function has the following arguments:</p>
<ol numeration="arabic">
<li>
<p>
The <code>id</code> attribute.
</p>
</li>
<li>
<p>
The <code>name</code> attribute.
</p>
</li>
<li>
<p>
Any other arbitrary attributes.
</p>
</li>
<li>
<p>
The result, given as an <code>Either</code> value. This will provide either the unparsed
input (when parsing failed) or the successfully parsed value. <code>intField</code> is a
great example of how this works. If you type in <em role="strong"><code>42</code></em>, the value of result
will be <code>Right 42</code>. But if you type in <em role="strong"><code>turtle</code></em>, the result will be <code>Left
&quot;turtle&quot;</code>. This lets you put in a value attribute on your input tag that will
give the user a consistent experience.
</p>
</li>
<li>
<p>
A <code>Bool</code> indicating if the field is required.
</p>
</li>
</ol>
<p>The final value in the constructor is <code>fieldEnctype</code>. If you’re dealing with
file uploads, this should be <code>Multipart</code>; otherwise, it should be <code>UrlEncoded</code>.</p>
<p>As a small example, let’s create a new field type that is a password confirm
field. This field has two text inputs- both with the same name attribute- and
returns an error message if the values don’t match. Note that, unlike most
fields, it does <em>not</em> provide a value attribute on the input tags, as you don’t
want to send back a user-entered password in your HTML <em role="strong">ever</em>.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">passwordConfirmField :: Field Handler Text
passwordConfirmField = Field
    { fieldParse = \rawVals _fileVals -&gt;
        case rawVals of
            [a, b]
                | a == b -&gt; return $ Right $ Just a
                | otherwise -&gt; return $ Left &quot;Passwords don&#39;t match&quot;
            [] -&gt; return $ Right Nothing
            _ -&gt; return $ Left &quot;You must enter two values&quot;
    , fieldView = \idAttr nameAttr otherAttrs eResult isReq -&gt;
        [whamlet|
            &lt;input id=#{idAttr} name=#{nameAttr} *{otherAttrs} type=password&gt;
            &lt;div&gt;Confirm:
            &lt;input id=#{idAttr}-confirm name=#{nameAttr} *{otherAttrs} type=password&gt;
        |]
    , fieldEnctype = UrlEncoded
    }

getHomeR :: Handler Html
getHomeR = do
    ((res, widget), enctype) &lt;- runFormGet $ renderDivs
        $ areq passwordConfirmField &quot;Password&quot; Nothing
    defaultLayout
        [whamlet|
            &lt;p&gt;Result: #{show res}
            &lt;form enctype=#{enctype}&gt;
                ^{widget}
                &lt;input type=submit value=&quot;Change password&quot;&gt;
        |]</code></pre>
</section>
<section id="forms_values_that_don_8217_t_come_from_the_user">
<h1>Values that don’t come from the user</h1>
<p>Imagine you’re writing a blog hosting web app, and you want to have a form for
users to enter a blog post. A blog post will consist of four pieces of
information:</p>
<ul>
<li>
<p>
Title
</p>
</li>
<li>
<p>
HTML contents
</p>
</li>
<li>
<p>
User ID of the author
</p>
</li>
<li>
<p>
Publication date
</p>
</li>
</ul>
<p>We want the user to enter the first two values, but not the second two. User ID
should be determined automatically by authenticating the user (a topic we
haven’t covered yet), and the publication date should just be the current time.
The question is, how do we keep our simple applicative form syntax, and yet
pull in values that don’t come from the user?</p>
<p>The answer is two separate helper functions:</p>
<ul>
<li>
<p>
<code>pure</code> allows us to wrap up a plain value as an applicative form value.
</p>
</li>
<li>
<p>
<code>lift</code> allows us to run arbitrary <code>Handler</code> actions inside an applicative form.
</p>
</li>
</ul>
<p>Let’s see an example of using these two functions:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell active web">{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}
import           Control.Applicative
import           Data.Text           (Text)
import           Data.Time
import           Yesod

-- In the authentication chapter, we&#39;ll address this properly
newtype UserId = UserId Int
    deriving Show

data App = App

mkYesod &quot;App&quot; [parseRoutes|
/ HomeR GET POST
|]

instance Yesod App

instance RenderMessage App FormMessage where
    renderMessage _ _ = defaultFormMessage

type Form a = Html -&gt; MForm Handler (FormResult a, Widget)

data Blog = Blog
    { blogTitle    :: Text
    , blogContents :: Textarea
    , blogUser     :: UserId
    , blogPosted   :: UTCTime
    }
    deriving Show

form :: UserId -&gt; Form Blog
form userId = renderDivs $ Blog
    &lt;$&gt; areq textField &quot;Title&quot; Nothing
    &lt;*&gt; areq textareaField &quot;Contents&quot; Nothing
    &lt;*&gt; pure userId
    &lt;*&gt; lift (liftIO getCurrentTime)

getHomeR :: Handler Html
getHomeR = do
    let userId = UserId 5 -- again, see the authentication chapter
    ((res, widget), enctype) &lt;- runFormPost $ form userId
    defaultLayout
        [whamlet|
            &lt;p&gt;Previous result: #{show res}
            &lt;form method=post action=@{HomeR} enctype=#{enctype}&gt;
                ^{widget}
                &lt;input type=submit&gt;
        |]

postHomeR :: Handler Html
postHomeR = getHomeR

main :: IO ()
main = warp 3000 App</code></pre>
<p>One trick we’ve introduced here is using the same handler code for both the
<code>GET</code> and <code>POST</code> request methods. This is enabled by the implementation of
<code>runFormPost</code>, which will behave exactly like <code>generateFormPost</code> in the case of
a <code>GET</code> request. Using the same handler for both request methods cuts down on
some boilerplate.</p>
</section>
<section id="forms_summary">
<h1>Summary</h1>
<p>Forms in Yesod are broken up into three groups. Applicative is the most common,
as it provides a nice user interface with an easy-to-use API. Monadic forms
give you more power, but are harder to use. Input forms are intended when you
just want to read data from the user, not generate the input widgets.</p>
<p>There are a number of different <code>Field</code>s provided by Yesod out-of-the-box. In
order to use these in your forms, you need to indicate the kind of form and
whether the field is required or optional. The result is six helper functions:
<code>areq</code>, <code>aopt</code>, <code>mreq</code>, <code>mopt</code>, <code>ireq</code>, and <code>iopt</code>.</p>
<p>Forms have significant power available. They can automatically insert
Javascript to help you leverage nicer UI controls, such as a jQuery UI date
picker. Forms are also fully i18n-ready, so you can support a global community
of users. And when you have more specific needs, you can slap on some
validation functions to an existing field, or write a new one from scratch.</p>
</section>
</article>
</section>
<section class="getting-started"><p class="warning">Note: You are looking at version 1.4 of the book, which is one version behind</p>
<h2> Chapters</h2>
<ul><li>Basics
<ul><li><a href="/book-1.4/introduction">Introduction</a>
</li>
<li><a href="/book-1.4/haskell">Haskell</a>
</li>
<li><a href="/book-1.4/basics">Basics</a>
</li>
<li><a href="/book-1.4/shakespearean-templates">Shakespearean Templates</a>
</li>
<li><a href="/book-1.4/widgets">Widgets</a>
</li>
<li><a href="/book-1.4/yesod-typeclass">Yesod Typeclass</a>
</li>
<li><a href="/book-1.4/routing-and-handlers">Routing and Handlers</a>
</li>
<li><a href="/book-1.4/forms">Forms</a>
</li>
<li><a href="/book-1.4/sessions">Sessions</a>
</li>
<li><a href="/book-1.4/persistent">Persistent</a>
</li>
<li><a href="/book-1.4/deploying-your-webapp">Deploying your Webapp</a>
</li>
</ul>
</li>
<li>Advanced
<ul><li><a href="/book-1.4/restful-content">RESTful Content</a>
</li>
<li><a href="/book-1.4/yesods-monads">Yesod’s Monads</a>
</li>
<li><a href="/book-1.4/authentication-and-authorization">Authentication and Authorization</a>
</li>
<li><a href="/book-1.4/scaffolding-and-the-site-template">Scaffolding and the Site Template</a>
</li>
<li><a href="/book-1.4/internationalization">Internationalization</a>
</li>
<li><a href="/book-1.4/creating-a-subsite">Creating a Subsite</a>
</li>
<li><a href="/book-1.4/understanding-request">Understanding a Request</a>
</li>
<li><a href="/book-1.4/sql-joins">SQL Joins</a>
</li>
<li><a href="/book-1.4/yesod-for-haskellers">Yesod for Haskellers</a>
</li>
</ul>
</li>
<li>Examples
<ul><li><a href="/book-1.4/initializing-foundation-data">Initializing data in the foundation datatype</a>
</li>
<li><a href="/book-1.4/blog-example-advanced">Blog: i18n, authentication, authorization, and database</a>
</li>
<li><a href="/book-1.4/wiki-chat-example">Wiki: markdown, chat subsite, event source</a>
</li>
<li><a href="/book-1.4/json-web-service">JSON Web Service</a>
</li>
<li><a href="/book-1.4/case-study-sphinx">Case Study: Sphinx-based Search</a>
</li>
<li><a href="/book-1.4/visitor-counter">Visitor counter</a>
</li>
<li><a href="/book-1.4/single-process-pubsub">Single process pub-sub</a>
</li>
<li><a href="/book-1.4/environment-variables">Environment variables for configuration</a>
</li>
<li><a href="/book-1.4/route-attributes">Route attributes</a>
</li>
</ul>
</li>
<li>Appendices
<ul><li><a href="/book-1.4/monad-control">monad-control</a>
</li>
<li><a href="/book-1.4/web-application-interface">Web Application Interface</a>
</li>
<li><a href="/book-1.4/settings-types">Settings Types</a>
</li>
<li><a href="/book-1.4/http-conduit">http-conduit</a>
</li>
<li><a href="/book-1.4/xml">xml-conduit</a>
</li>
</ul>
</li>
</ul>
</section>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script><script src="//ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script><script>var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function c(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function j(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function g(t,s){var r="";for(var q=0;q<t.childNodes.length;q++){if(t.childNodes[q].nodeType==3){var p=t.childNodes[q].nodeValue;if(s){p=p.replace(/\n/g,"")}r+=p}else{if(t.childNodes[q].nodeName=="BR"){r+="\n"}else{r+=g(t.childNodes[q])}}}if(/MSIE [678]/.test(navigator.userAgent)){r=r.replace(/\r/g,"\n")}return r}function a(s){var q=s.className.split(/\s+/);q=q.concat(s.parentNode.className.split(/\s+/));for(var p=0;p<q.length;p++){var r=q[p].replace(/^language-/,"");if(d[r]||r=="no-highlight"){return r}}}function b(p){var q=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{q.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);q.push({event:"stop",offset:t,node:s.childNodes[r]})}}}return t})(p,0);return q}function l(y,z,x){var r=0;var w="";var t=[];function u(){if(y.length&&z.length){if(y[0].offset!=z[0].offset){return(y[0].offset<z[0].offset)?y:z}else{return z[0].event=="start"?y:z}}else{return y.length?y:z}}function s(C){var D="<"+C.nodeName.toLowerCase();for(var A=0;A<C.attributes.length;A++){var B=C.attributes[A];D+=" "+B.nodeName.toLowerCase();if(B.nodeValue!=undefined&&B.nodeValue!=false&&B.nodeValue!=null){D+='="'+m(B.nodeValue)+'"'}}return D+">"}while(y.length||z.length){var v=u().splice(0,1)[0];w+=m(x.substr(r,v.offset-r));r=v.offset;if(v.event=="start"){w+=s(v.node);t.push(v.node)}else{if(v.event=="stop"){var q=t.length;do{q--;var p=t[q];w+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);t.splice(q,1);while(q<t.length){w+=s(t[q]);q++}}}}w+=x.substr(r);return w}function i(){function p(u,t,v){if(u.compiled){return}if(!v){u.bR=c(t,u.b?u.b:"\\B|\\b");if(!u.e&&!u.eW){u.e="\\B|\\b"}if(u.e){u.eR=c(t,u.e)}}if(u.i){u.iR=c(t,u.i)}if(u.r==undefined){u.r=1}if(u.k){u.lR=c(t,u.l||hljs.IR,true)}for(var s in u.k){if(!u.k.hasOwnProperty(s)){continue}if(u.k[s] instanceof Object){u.kG=u.k}else{u.kG={keyword:u.k}}break}if(!u.c){u.c=[]}u.compiled=true;for(var r=0;r<u.c.length;r++){p(u.c[r],t,false)}if(u.starts){p(u.starts,t,false)}}for(var q in d){if(!d.hasOwnProperty(q)){continue}p(d[q].dM,d[q],true)}}function e(J,D){if(!i.called){i();i.called=true}function z(r,M){for(var L=0;L<M.c.length;L++){if(M.c[L].bR.test(r)){return M.c[L]}}}function w(L,r){if(C[L].e&&C[L].eR.test(r)){return 1}if(C[L].eW){var M=w(L-1,r);return M?M+1:0}return 0}function x(r,L){return L.iR&&L.iR.test(r)}function A(O,N){var M=[];for(var L=0;L<O.c.length;L++){M.push(O.c[L].b)}var r=C.length-1;do{if(C[r].e){M.push(C[r].e)}r--}while(C[r+1].eW);if(O.i){M.push(O.i)}return c(N,"("+M.join("|")+")",true)}function s(M,L){var N=C[C.length-1];if(!N.t){N.t=A(N,H)}N.t.lastIndex=L;var r=N.t.exec(M);if(r){return[M.substr(L,r.index-L),r[0],false]}else{return[M.substr(L),"",true]}}function p(O,r){var L=H.cI?r[0].toLowerCase():r[0];for(var N in O.kG){if(!O.kG.hasOwnProperty(N)){continue}var M=O.kG[N].hasOwnProperty(L);if(M){return[N,M]}}return false}function F(M,O){if(!O.k){return m(M)}var N="";var P=0;O.lR.lastIndex=0;var L=O.lR.exec(M);while(L){N+=m(M.substr(P,L.index-P));var r=p(O,L);if(r){t+=r[1];N+='<span class="'+r[0]+'">'+m(L[0])+"</span>"}else{N+=m(L[0])}P=O.lR.lastIndex;L=O.lR.exec(M)}N+=m(M.substr(P,M.length-P));return N}function K(r,M){if(M.sL&&d[M.sL]){var L=e(M.sL,r);t+=L.keyword_count;return L.value}else{return F(r,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){q+=L;M.buffer=""}else{if(M.eB){q+=m(r)+L;M.buffer=""}else{q+=L;M.buffer=r}}C.push(M);B+=M.r}function E(O,L,Q){var R=C[C.length-1];if(Q){q+=K(R.buffer+O,R);return false}var M=z(L,R);if(M){q+=K(R.buffer+O,R);I(M,L);return M.rB}var r=w(C.length-1,L);if(r){var N=R.cN?"</span>":"";if(R.rE){q+=K(R.buffer+O,R)+N}else{if(R.eE){q+=K(R.buffer+O,R)+N+m(L)}else{q+=K(R.buffer+O+L,R)+N}}while(r>1){N=C[C.length-2].cN?"</span>":"";q+=N;r--;C.length--}var P=C[C.length-1];C.length--;C[C.length-1].buffer="";if(P.starts){I(P.starts,"")}return R.rE}if(x(L,R)){throw"Illegal"}}var H=d[J];var C=[H.dM];var B=0;var t=0;var q="";try{var v=0;H.dM.buffer="";do{var y=s(D,v);var u=E(y[0],y[1],y[2]);v+=y[0].length;if(!u){v+=y[1].length}}while(!y[2]);if(C.length>1){throw"Illegal"}return{r:B,keyword_count:t,value:q}}catch(G){if(G=="Illegal"){return{r:0,keyword_count:0,value:m(D)}}else{throw G}}}function f(t){var r={keyword_count:0,r:0,value:m(t)};var q=r;for(var p in d){if(!d.hasOwnProperty(p)){continue}var s=e(p,t);s.language=p;if(s.keyword_count+s.r>q.keyword_count+q.r){q=s}if(s.keyword_count+s.r>r.keyword_count+r.r){q=r;r=s}}if(q.language){r.second_best=q}return r}function h(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function o(u,x,q){var y=g(u,q);var s=a(u);if(s=="no-highlight"){return}if(s){var w=e(s,y)}else{var w=f(y);s=w.language}var p=b(u);if(p.length){var r=document.createElement("pre");r.innerHTML=w.value;w.value=l(p,b(r),y)}w.value=h(w.value,x,q);var t=u.className;if(!t.match("(\\s|^)(language-)?"+s+"(\\s|$)")){t=t?(t+" "+s):s}if(/MSIE [678]/.test(navigator.userAgent)&&u.tagName=="CODE"&&u.parentNode.tagName=="PRE"){var r=u.parentNode;var v=document.createElement("div");v.innerHTML="<pre><code>"+w.value+"</code></pre>";u=v.firstChild.firstChild;v.firstChild.cN=r.cN;r.parentNode.replaceChild(v.firstChild,r)}else{u.innerHTML=w.value}u.className=t;u.result={language:s,kw:w.keyword_count,re:w.r};if(w.second_best){u.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function k(){if(k.called){return}k.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=j(r[p]);if(q){o(q,hljs.tabReplace)}}}function n(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",k,false);window.addEventListener("load",k,false)}else{if(window.attachEvent){window.attachEvent("onload",k)}else{window.onload=k}}}var d={};this.LANGUAGES=d;this.highlight=e;this.highlightAuto=f;this.fixMarkup=h;this.highlightBlock=o;this.initHighlighting=k;this.initHighlightingOnLoad=n;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0x[A-Za-z0-9]+|\\d+(\\.\\d+)?)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.inherit=function(p,s){var r={};for(var q in p){r[q]=p[q]}if(s){for(var q in s){r[q]=s[q]}}return r}}();hljs.LANGUAGES.bash=function(){var d={"true":1,"false":1};var b={cN:"variable",b:"\\$([a-zA-Z0-9_]+)\\b"};var a={cN:"variable",b:"\\$\\{(([^}])|(\\\\}))+\\}",c:[hljs.CNM]};var c={cN:"string",b:'"',e:'"',i:"\\n",c:[hljs.BE,b,a],r:0};var e={cN:"test_condition",b:"",e:"",c:[c,b,a,hljs.CNM],k:{literal:d},r:0};return{dM:{k:{keyword:{"if":1,then:1,"else":1,fi:1,"for":1,"break":1,"continue":1,"while":1,"in":1,"do":1,done:1,echo:1,exit:1,"return":1,set:1,declare:1},literal:d},c:[{cN:"shebang",b:"(#!\\/bin\\/bash)|(#!\\/bin\\/sh)",r:10},hljs.HCM,hljs.CNM,c,b,a,hljs.inherit(e,{b:"\\[ ",e:" \\]",r:0}),hljs.inherit(e,{b:"\\[\\[ ",e:" \\]\\]"})]}}}();hljs.LANGUAGES.javascript={dM:{k:{keyword:{"in":1,"if":1,"for":1,"while":1,"finally":1,"var":1,"new":1,"function":1,"do":1,"return":1,"void":1,"else":1,"break":1,"catch":1,"instanceof":1,"with":1,"throw":1,"case":1,"default":1,"try":1,"this":1,"switch":1,"continue":1,"typeof":1,"delete":1},literal:{"true":1,"false":1,"null":1}},c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM,hljs.CNM,{b:"("+hljs.RSR+"|case|return|throw)\\s*",k:{"return":1,"throw":1,"case":1},c:[hljs.CLCM,hljs.CBLCLM,{cN:"regexp",b:"/",e:"/[gim]*",c:[{b:"\\\\/"}]}],r:0},{cN:"function",b:"\\bfunction\\b",e:"{",k:{"function":1},c:[{cN:"title",b:"[A-Za-z$_][0-9A-Za-z$_]*"},{cN:"params",b:"\\(",e:"\\)",c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM]}]}]}};hljs.LANGUAGES.css=function(){var a={cN:"function",b:hljs.IR+"\\(",e:"\\)",c:[{eW:true,eE:true,c:[hljs.NM,hljs.ASM,hljs.QSM]}]};return{cI:true,dM:{i:"[=/|']",c:[hljs.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:{"font-face":1,page:1}},{cN:"at_rule",b:"@",e:"[{;]",eE:true,k:{"import":1,page:1,media:1,charset:1},c:[a,hljs.ASM,hljs.QSM,hljs.NM]},{cN:"tag",b:hljs.IR,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[hljs.CBLCLM,{cN:"rule",b:"[^\\s]",rB:true,e:";",eW:true,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:true,i:"[^\\s]",starts:{cN:"value",eW:true,eE:true,c:[a,hljs.NM,hljs.QSM,hljs.ASM,hljs.CBLCLM,{cN:"hexcolor",b:"\\#[0-9A-F]+"},{cN:"important",b:"!important"}]}}]}]}]}}}();hljs.LANGUAGES.xml=function(){var b="[A-Za-z0-9\\._:-]+";var a={eW:true,c:[{cN:"attribute",b:b,r:0},{b:'="',rB:true,e:'"',c:[{cN:"value",b:'"',eW:true}]},{b:"='",rB:true,e:"'",c:[{cN:"value",b:"'",eW:true}]},{b:"=",c:[{cN:"value",b:"[^\\s/>]+"}]}]};return{cI:true,dM:{c:[{cN:"pi",b:"<\\?",e:"\\?>",r:10},{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style",e:">",k:{title:{style:1}},c:[a],starts:{cN:"css",e:"</style>",rE:true,sL:"css"}},{cN:"tag",b:"<script",e:">",k:{title:{script:1}},c:[a],starts:{cN:"javascript",e:"<\/script>",rE:true,sL:"javascript"}},{cN:"vbscript",b:"<%",e:"%>",sL:"vbscript"},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ />]+"},a]}]}}}();hljs.LANGUAGES.java={dM:{k:{"false":1,"synchronized":1,"int":1,"abstract":1,"float":1,"private":1,"char":1,"interface":1,"boolean":1,"static":1,"null":1,"if":1,"const":1,"for":1,"true":1,"while":1,"long":1,"throw":1,strictfp:1,"finally":1,"protected":1,"extends":1,"import":1,"native":1,"final":1,"implements":1,"return":1,"void":1,"enum":1,"else":1,"break":1,"transient":1,"new":1,"catch":1,"instanceof":1,"byte":1,"super":1,"class":1,"volatile":1,"case":1,assert:1,"short":1,"package":1,"default":1,"double":1,"public":1,"try":1,"this":1,"switch":1,"continue":1,"throws":1},c:[{cN:"javadoc",b:"/\\*\\*",e:"\\*/",c:[{cN:"javadoctag",b:"@[A-Za-z]+"}],r:10},hljs.CLCM,hljs.CBLCLM,hljs.ASM,hljs.QSM,{cN:"class",b:"(class |interface )",e:"{",k:{"class":1,"interface":1},i:":",c:[{b:"(implements|extends)",k:{"extends":1,"implements":1},r:10},{cN:"title",b:hljs.UIR}]},hljs.CNM,{cN:"annotation",b:"@[A-Za-z]+"}]}};hljs.LANGUAGES.haskell=function(){var a={cN:"label",b:"\\b[A-Z][\\w']*",r:0};var b={cN:"container",b:"\\(",e:"\\)",c:[{cN:"label",b:"\\b[A-Z][\\w\\(\\)\\.']*"},{cN:"title",b:"[_a-z][\\w']*"}]};return{dM:{k:{keyword:{let:1,"in":1,"if":1,then:1,"else":1,"case":1,of:1,where:1,"do":1,module:1,"import":1,hiding:1,qualified:1,type:1,data:1,newtype:1,deriving:1,"class":1,instance:1,"null":1,not:1,as:1}},c:[{cN:"comment",b:"--",e:"$"},{cN:"comment",b:"{-",e:"-}"},{cN:"string",b:"\\s+'",e:"'",c:[hljs.BE],r:0},hljs.QSM,{cN:"import",b:"\\bimport",e:"$",k:{"import":1,qualified:1,as:1,hiding:1},c:[b]},{cN:"module",b:"\\bmodule",e:"where",k:{module:1,where:1},c:[b]},{cN:"class",b:"\\b(class|instance|data|(new)?type)",e:"(where|$)",k:{"class":1,where:1,instance:1,data:1,type:1,newtype:1,deriving:1},c:[a]},hljs.CNM,{cN:"shebang",b:"#!\\/usr\\/bin\\/env runhaskell",e:"$"},a,{cN:"title",b:"^[_a-z][\\w']*"}]}}}();hljs.LANGUAGES.sql={cI:true,dM:{i:"[^\\s]",c:[{cN:"operator",b:"(begin|start|commit|rollback|savepoint|lock|alter|create|drop|rename|call|delete|do|handler|insert|load|replace|select|truncate|update|set|show|pragma)\\b",e:";|$",k:{keyword:{all:1,partial:1,global:1,month:1,current_timestamp:1,using:1,go:1,revoke:1,smallint:1,indicator:1,"end-exec":1,disconnect:1,zone:1,"with":1,character:1,assertion:1,to:1,add:1,current_user:1,usage:1,input:1,local:1,alter:1,match:1,collate:1,real:1,then:1,rollback:1,get:1,read:1,timestamp:1,session_user:1,not:1,integer:1,bit:1,unique:1,day:1,minute:1,desc:1,insert:1,execute:1,like:1,ilike:2,level:1,decimal:1,drop:1,"continue":1,isolation:1,found:1,where:1,constraints:1,domain:1,right:1,national:1,some:1,module:1,transaction:1,relative:1,second:1,connect:1,escape:1,close:1,system_user:1,"for":1,deferred:1,section:1,cast:1,current:1,sqlstate:1,allocate:1,intersect:1,deallocate:1,numeric:1,"public":1,preserve:1,full:1,"goto":1,initially:1,asc:1,no:1,key:1,output:1,collation:1,group:1,by:1,union:1,session:1,both:1,last:1,language:1,constraint:1,column:1,of:1,space:1,foreign:1,deferrable:1,prior:1,connection:1,unknown:1,action:1,commit:1,view:1,or:1,first:1,into:1,"float":1,year:1,primary:1,cascaded:1,except:1,restrict:1,set:1,references:1,names:1,table:1,outer:1,open:1,select:1,size:1,are:1,rows:1,from:1,prepare:1,distinct:1,leading:1,create:1,only:1,next:1,inner:1,authorization:1,schema:1,corresponding:1,option:1,declare:1,precision:1,immediate:1,"else":1,timezone_minute:1,external:1,varying:1,translation:1,"true":1,"case":1,exception:1,join:1,hour:1,"default":1,"double":1,scroll:1,value:1,cursor:1,descriptor:1,values:1,dec:1,fetch:1,procedure:1,"delete":1,and:1,"false":1,"int":1,is:1,describe:1,"char":1,as:1,at:1,"in":1,varchar:1,"null":1,trailing:1,any:1,absolute:1,current_time:1,end:1,grant:1,privileges:1,when:1,cross:1,check:1,write:1,current_date:1,pad:1,begin:1,temporary:1,exec:1,time:1,update:1,catalog:1,user:1,sql:1,date:1,on:1,identity:1,timezone_hour:1,natural:1,whenever:1,interval:1,work:1,order:1,cascade:1,diagnostics:1,nchar:1,having:1,left:1,call:1,"do":1,handler:1,load:1,replace:1,truncate:1,start:1,lock:1,show:1,pragma:1},aggregate:{count:1,sum:1,min:1,max:1,avg:1}},c:[{cN:"string",b:"'",e:"'",c:[hljs.BE,{b:"''"}],r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE,{b:'""'}],r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},hljs.CNM,{b:"\\n"}]},hljs.CBLCLM,{cN:"comment",b:"--",e:"$"}]}};hljs.LANGUAGES.nginx=function(){var c={cN:"variable",b:"\\$\\d+"};var b={cN:"variable",b:"\\${",e:"}"};var a={cN:"variable",b:"[\\$\\@]"+hljs.UIR};return{dM:{c:[hljs.HCM,{b:hljs.UIR,e:";|{",rE:true,k:{accept_mutex:1,accept_mutex_delay:1,access_log:1,add_after_body:1,add_before_body:1,add_header:1,addition_types:1,alias:1,allow:1,ancient_browser:1,ancient_browser:1,ancient_browser_value:1,ancient_browser_value:1,auth_basic:1,auth_basic_user_file:1,autoindex:1,autoindex_exact_size:1,autoindex_localtime:1,"break":1,charset:1,charset:1,charset_map:1,charset_map:1,charset_types:1,charset_types:1,client_body_buffer_size:1,client_body_in_file_only:1,client_body_in_single_buffer:1,client_body_temp_path:1,client_body_timeout:1,client_header_buffer_size:1,client_header_timeout:1,client_max_body_size:1,connection_pool_size:1,connections:1,create_full_put_path:1,daemon:1,dav_access:1,dav_methods:1,debug_connection:1,debug_points:1,default_type:1,deny:1,directio:1,directio_alignment:1,echo:1,echo_after_body:1,echo_before_body:1,echo_blocking_sleep:1,echo_duplicate:1,echo_end:1,echo_exec:1,echo_flush:1,echo_foreach_split:1,echo_location:1,echo_location_async:1,echo_read_request_body:1,echo_request_body:1,echo_reset_timer:1,echo_sleep:1,echo_subrequest:1,echo_subrequest_async:1,empty_gif:1,empty_gif:1,env:1,error_log:1,error_log:1,error_page:1,events:1,expires:1,fastcgi_bind:1,fastcgi_buffer_size:1,fastcgi_buffers:1,fastcgi_busy_buffers_size:1,fastcgi_cache:1,fastcgi_cache_key:1,fastcgi_cache_methods:1,fastcgi_cache_min_uses:1,fastcgi_cache_path:1,fastcgi_cache_use_stale:1,fastcgi_cache_valid:1,fastcgi_catch_stderr:1,fastcgi_connect_timeout:1,fastcgi_hide_header:1,fastcgi_ignore_client_abort:1,fastcgi_ignore_headers:1,fastcgi_index:1,fastcgi_intercept_errors:1,fastcgi_max_temp_file_size:1,fastcgi_next_upstream:1,fastcgi_param:1,fastcgi_pass:1,fastcgi_pass_header:1,fastcgi_pass_request_body:1,fastcgi_pass_request_headers:1,fastcgi_read_timeout:1,fastcgi_send_lowat:1,fastcgi_send_timeout:1,fastcgi_split_path_info:1,fastcgi_store:1,fastcgi_store_access:1,fastcgi_temp_file_write_size:1,fastcgi_temp_path:1,fastcgi_upstream_fail_timeout:1,fastcgi_upstream_max_fails:1,flv:1,geo:1,geo:1,geoip_city:1,geoip_country:1,gzip:1,gzip_buffers:1,gzip_comp_level:1,gzip_disable:1,gzip_hash:1,gzip_http_version:1,gzip_min_length:1,gzip_no_buffer:1,gzip_proxied:1,gzip_static:1,gzip_types:1,gzip_vary:1,gzip_window:1,http:1,"if":1,if_modified_since:1,ignore_invalid_headers:1,image_filter:1,image_filter_buffer:1,image_filter_jpeg_quality:1,image_filter_transparency:1,include:1,index:1,internal:1,ip_hash:1,js:1,js_load:1,js_require:1,js_utf8:1,keepalive_requests:1,keepalive_timeout:1,kqueue_changes:1,kqueue_events:1,large_client_header_buffers:1,limit_conn:1,limit_conn_log_level:1,limit_except:1,limit_rate:1,limit_rate_after:1,limit_req:1,limit_req_log_level:1,limit_req_zone:1,limit_zone:1,lingering_time:1,lingering_timeout:1,listen:1,location:1,lock_file:1,log_format:1,log_not_found:1,log_subrequest:1,map:1,map_hash_bucket_size:1,map_hash_max_size:1,master_process:1,memcached_bind:1,memcached_buffer_size:1,memcached_connect_timeout:1,memcached_next_upstream:1,memcached_pass:1,memcached_read_timeout:1,memcached_send_timeout:1,memcached_upstream_fail_timeout:1,memcached_upstream_max_fails:1,merge_slashes:1,min_delete_depth:1,modern_browser:1,modern_browser:1,modern_browser_value:1,modern_browser_value:1,more_clear_headers:1,more_clear_input_headers:1,more_set_headers:1,more_set_input_headers:1,msie_padding:1,msie_refresh:1,multi_accept:1,open_file_cache:1,open_file_cache_errors:1,open_file_cache_events:1,open_file_cache_min_uses:1,open_file_cache_retest:1,open_file_cache_valid:1,open_log_file_cache:1,optimize_server_names:1,output_buffers:1,override_charset:1,override_charset:1,perl:1,perl_modules:1,perl_require:1,perl_set:1,pid:1,port_in_redirect:1,post_action:1,postpone_gzipping:1,postpone_output:1,proxy_bind:1,proxy_buffer_size:1,proxy_buffering:1,proxy_buffers:1,proxy_busy_buffers_size:1,proxy_cache:1,proxy_cache_key:1,proxy_cache_methods:1,proxy_cache_min_uses:1,proxy_cache_path:1,proxy_cache_use_stale:1,proxy_cache_valid:1,proxy_connect_timeout:1,proxy_headers_hash_bucket_size:1,proxy_headers_hash_max_size:1,proxy_hide_header:1,proxy_ignore_client_abort:1,proxy_ignore_headers:1,proxy_intercept_errors:1,proxy_max_temp_file_size:1,proxy_method:1,proxy_next_upstream:1,proxy_pass:1,proxy_pass_header:1,proxy_pass_request_body:1,proxy_pass_request_headers:1,proxy_read_timeout:1,proxy_redirect:1,proxy_send_lowat:1,proxy_send_timeout:1,proxy_set_body:1,proxy_set_header:1,proxy_store:1,proxy_store_access:1,proxy_temp_file_write_size:1,proxy_temp_path:1,proxy_upstream_fail_timeout:1,proxy_upstream_max_fails:1,push_authorized_channels_only:1,push_channel_group:1,push_max_channel_id_length:1,push_max_channel_subscribers:1,push_max_message_buffer_length:1,push_max_reserved_memory:1,push_message_buffer_length:1,push_message_timeout:1,push_min_message_buffer_length:1,push_min_message_recipients:1,push_publisher:1,push_store_messages:1,push_subscriber:1,push_subscriber_concurrency:1,random_index:1,read_ahead:1,real_ip_header:1,recursive_error_pages:1,request_pool_size:1,reset_timedout_connection:1,resolver:1,resolver_timeout:1,"return":1,rewrite:1,rewrite_log:1,root:1,satisfy:1,satisfy_any:1,send_lowat:1,send_timeout:1,sendfile:1,sendfile_max_chunk:1,server:1,server:1,server_name:1,server_name_in_redirect:1,server_names_hash_bucket_size:1,server_names_hash_max_size:1,server_tokens:1,set:1,set_real_ip_from:1,source_charset:1,source_charset:1,ssi:1,ssi_ignore_recycled_buffers:1,ssi_min_file_chunk:1,ssi_silent_errors:1,ssi_types:1,ssi_value_length:1,ssl:1,ssl_certificate:1,ssl_certificate_key:1,ssl_ciphers:1,ssl_client_certificate:1,ssl_crl:1,ssl_dhparam:1,ssl_prefer_server_ciphers:1,ssl_protocols:1,ssl_session_cache:1,ssl_session_timeout:1,ssl_verify_client:1,ssl_verify_depth:1,sub_filter:1,sub_filter_once:1,sub_filter_types:1,tcp_nodelay:1,tcp_nopush:1,timer_resolution:1,try_files:1,types:1,types_hash_bucket_size:1,types_hash_max_size:1,underscores_in_headers:1,uninitialized_variable_warn:1,upstream:1,use:1,user:1,userid:1,userid:1,userid_domain:1,userid_domain:1,userid_expires:1,userid_expires:1,userid_mark:1,userid_name:1,userid_name:1,userid_p3p:1,userid_p3p:1,userid_path:1,userid_path:1,userid_service:1,userid_service:1,valid_referers:1,variables_hash_bucket_size:1,variables_hash_max_size:1,worker_connections:1,worker_cpu_affinity:1,worker_priority:1,worker_processes:1,worker_rlimit_core:1,worker_rlimit_nofile:1,worker_rlimit_sigpending:1,working_directory:1,xml_entities:1,xslt_stylesheet:1,xslt_types:1},r:0,c:[hljs.HCM,{b:"\\s",e:"[;{]",rB:true,rE:true,l:"[a-z/]+",k:{built_in:{on:1,off:1,yes:1,no:1,"true":1,"false":1,none:1,blocked:1,debug:1,info:1,notice:1,warn:1,error:1,crit:1,select:1,permanent:1,redirect:1,kqueue:1,rtsig:1,epoll:1,poll:1,"/dev/poll":1}},r:0,c:[hljs.HCM,{cN:"string",b:'"',e:'"',c:[hljs.BE,c,b,a],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE,c,b,a],r:0},{cN:"string",b:"([a-z]+):/",e:"[;\\s]",rE:true},{cN:"regexp",b:"\\s\\^",e:"\\s|{|;",rE:true,c:[hljs.BE,c,b,a]},{cN:"regexp",b:"~\\*?\\s+",e:"\\s|{|;",rE:true,c:[hljs.BE,c,b,a]},{cN:"regexp",b:"\\*(\\.[a-z\\-]+)+",c:[hljs.BE,c,b,a]},{cN:"regexp",b:"([a-z\\-]+\\.)+\\*",c:[hljs.BE,c,b,a]},{cN:"number",b:"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b"},{cN:"number",b:"\\s\\d+[kKmMgGdshdwy]*\\b",r:0},c,b,a]}]}]}}}();$(function(){
    $.each($("section[id] > h1"), function(i, e){
        var $e = $(e),
            link = $("<a class='permalink'>¶</a>");
        link.attr("href", "#" + $e.parent().attr("id"));

        $e.prepend(link);
    });
});
hljs.initHighlightingOnLoad();
</script><footer id="license" style="text-align:center;font-size:0.8em">All content on this site is available under the
<a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
<br>
Content outside the book section is available under
<a href="https://raw.github.com/yesodweb/yesodweb.com/master/LICENSE">the MIT license</a>
as well.</footer>
</div></div><script>window._gaq = [['_setAccount','UA-1434510-13'],['_trackPageview'],['_trackPageLoadTime']];(function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script><!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>